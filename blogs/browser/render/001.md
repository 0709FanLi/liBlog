---
title: 记录从输入URL到页面呈现发生了什么
date: 2023-03-05
tags:
  - browser
categories:
  - browser
sidebar: "auto"
---

`从输入URL到页面呈现发生了什么`了解这个需要准备一些知识点：

- [记录浏览器缓存](https://juejin.cn/post/7000266982004097031)
- [tcp 三次握手和四次挥手](https://juejin.cn/post/6999512122744897573)
- 上下文无关文法
  **以输入 www.baidu.com 为例**

## 网络

### 网络请求

#### 1. 构建请求

浏览器会构建请求行

```
// 请求方法是GET，路径为根路径，HTTP协议版本为1.1
GET / HTTP/1.1
```

#### 2. 查找强缓存

先查找强缓存如果命中直接使用缓存，否则进入到下一步，可看链接[记录浏览器缓存](https://juejin.cn/post/7000266982004097031) .

#### 3. DNS 解析

我们输入的是域名，而数据包是通过 IP 地址发送到服务器的，因此我们需要拿到对应的 IP 地址。这个过程需要一个服务系统，通过域名拿到 IP 地址，这个系统就是`DNS(Domain name resolution)`域名解析系统。

**DNS 解析过程**

1. 首先搜索浏览器自身的 DNS 缓存，如果存在，则解析到此完成。
2. 如果不存在，尝试读取 hosts 文件是否有对应映射关系，如果存在则到此完成
3. 如果 hosts 文件不存在映射关系，则查找本地 DNS 服务器（ISP 服务器，或者自己手动设置的 DNS 服务器），如果存在，到此完成
4. 如果本地 DNS 服务器没找到，它就会向根服务器发出请求，进行递归查询。

#### 4. TCP 链接

这里提醒一点，Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 链接，超过的话剩下的请求就需要等待。关于 TCP 可看文章开头的链接

建立 TCP 链接需要经过三个阶段：

1. 通过三次握手建立客户端和服务端的链接
2. 进行数据传输。这里有一个重要的机制就是说发送数据包之后必须要向发送发`确认`，如果发送方没有收到确认就认为是数据包丢失，重新发包。发送的时候还有要给优化策略，包可以`拆成一个一个小包依次传输`，接收方按照这个小包的顺序把它们组装成完整的数据包。
3. 数据传输完成，四次挥手断开链接

#### 5. 发送 http 请求

TCP 链接建立之后，就开始进行通信，也就是发送 http 请求，浏览器发送 http 请求主要由三部分组成，`请求行`，`请求头`，`请求体`

```
// 请求方法是GET，路径为根路径 协议版本为 1.1
GET / HTTP/1.1
```

同时也要携带一些请求头，比如说强缓存相关`Cache-Control`,协商缓存相关`If-Modified-Since`,`If-None-Match`,还有一些其它的字段，列举如下

```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: no-cache
Connection: keep-alive
Cookie: /* 省略cookie信息 */
Host: www.baidu.com
Pragma: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1

```

请求体只有请求方式是`POST`的方法下存在，常见的场景就是**表单提交**;

### 网络响应

服务器收到请求后，对请求进行处理，把数据传回浏览器也就是返回网络响应；

响应头包含了服务器及其返回数据的一些信息，服务器生成数据的时间，返回的数据类型以及 cookie 信息

```
Cache-Control: no-cache
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Wed, 04 Dec 2019 12:29:13 GMT
Server: apache
Set-Cookie: rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.baidu.com

```

相应完成之后会关闭这个 TCP 链接吗？

不一定。如果请求头或者响应头包含`Connection:Keep-Alive`,表示建立了持久连接，这样 TCP 连接会一直保持，之后请求统一站点的资源回复用这个连接；

断开 TCP 链接，请求—响应流程结束。

### 总结

总结下主要内容，网络请求过程

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d883f40dd4145ca887981318b6575f5~tplv-k3u1fbpfcp-watermark.image)

### 解析算法

#### 构建 DOM 树

##### HTML 文法的本质

##### 解析算法

HTML[规范](https://html.spec.whatwg.org/multipage/parsing.html)详细的介绍了解析算法，这个算法分为两个阶段

1. 标记化
2. 建树

对应的这两个过程就是**词法分析**和**语法分析**。

**标记化算法**

这个算法输入为`HTML文本`，输出为`HTML标记`，也称为`标记生成器`。起中运用`有限自动状态机`来完成，也就是说接受一个或多个字符，就会更新到下一个状态。

```
<html>
  <body>
    Hello sanyuan
  </body>
</html>
```

通过一个简单的例子来演示下`标记化`的过程。

1. 接收到`<`，状态为**标记打开**
2. 接受`[a-z]`的字符，会进入**标记名称**状态。
3. 这个状态一直保持，直到遇到`>`,表示标记名称记录完成，这时候变为**数据状态**
4. 接下来`<body>`做同样的处理，这个时候 html 和 body 的标记都做好了
5. 现在来到`<body>`中的`>`,进入数据状态，之后保持这样状态接收后面字符**Hello world**。
6. 接着接收`</body>`中的`<`，回到标记打开，接收下一个`/`后，这时候会创建一个`end tag`的 token
7. 随后进入**标记名称状态**，遇到`>`回到**数据状态**
8. 接着以同样的方式处理`</body>`

总结：

- `<`进入 标记打开
- `[a-z]`进入 标记名称状态
- `/` 创建一个 `end tag`的 token
- `>` 进入数据状态

**建树算法**

DOM 树是一个以`document`为根节点的多叉树。因此解析器会首先创建一个`document`对象。标记生成器会把每个标记的信息发送给**建树器**。**建树器**接收到相应的标记时，**会创建响应的 DOM 对象**，创建这个`DOM`对象后会做两件事情

1. 将**DOM 对象**加入 DOM 树中
2. 将对应标记压入存放开放（与`闭合标签`意思对应）元素的栈中。

还是拿下边的例子说

```
<html>
  <body>
    Hello sanyuan
  </body>
</html>

```

1. 接收到标记生成器传来的`html`标签，这时候变成**before html**状态。同时创建一个`HTMLHtmlElement`的 DOM 元素，将其加到`document`根对象上，并进行压栈操作。
2. 接着状态自动变为**before head**，此时标记生成器那边传来`body`，表示没有`head`,这个时候建树器会自动创建一个**HTMLHeadElement**并将其加入到`DOM树`中
3. 现在进入到**in head**状态，然后直接跳到**after head**
4. 现在**标记生成器**传来了`body`标记，创建**HTMLBodyElement**,插入到`DOM树`中，同时压入到开放标记栈。
5. 接着进入**in body**，然后接收后面一系列的字符：**Hello World!**。接收到第一个字符的时候，会创建一个**TEXT**节点并把字符插入其中，然后把**TEXT**节点插入到`DOM树`中`body元素`的下面。随着不断接收后边的字符，这些字符会附在**TEXT**节点上。

6. 现在**标记生成器**传来一个`body`的结束标记，进入到**after body**状态
7. **标记生成器**最后传来一个`html`的结束标记，进入到**after html**的状态，表示解析或称到此结束

**容错机制**

讲到`HTML规范`，就不得不说它强大的**宽容策略**，容错能力非常强，虽然大家褒贬不一，不过我想作为一名前端工程师，有必要知道`HTML Parser`在容错方面做了哪些事情

接下来是 WebKit 中一些经典的容错示例，发现有其它的也欢迎来补充

1. 使用`</br>`而不是`<br>`

```
if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
  reportError(MalformedBRError);
  t->beginTag = true;
}
```

全部转化为`br`的形式

2. 表格离散

```
<table>
  <table>
    <tr><td>inner table</td></tr>
  </table>
  <tr><td>outer table</td></tr>
</table>

```

`WebKit`会自动转化为：

```
<table>
    <tr><td>outer table</td></tr>
</table>
<table>
    <tr><td>inner table</td></tr>
</table>

```

3. 表单嵌套元素
   这时候会直接忽视里边的`form`,

#### 样式计算

关于 css 样式，它的来源一般是 3 种：

1. **link 标签引用**
2. **style 标签中的样式**
3. **l 元素的内嵌 style 属性**

##### 格式化样式表

首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 问之后第一件事情就是将其转化为一个结构化的对象，即 styleSheets.

这个格式化的过程过于复杂，而且不同的浏览器会有不同的优化策略，这里就不展开了。

在浏览器控制台能通过`document.styleSheets`来查看这个最终的结构。这个结构包含了以上三种来源，为后面的样式操作提供了基础。

##### 标准化样式属性

有一些 CSS 样式的数值并不容易被渲染引擎理解，因此要在计算样式之前将它们标准化，如`em`->`px`,`red`->`#ff0000`,`bold`->`700`等等

##### 计算每个节点的具体样式

样式已经被`格式化`和`标准化`，接下来就是计算每个节点的具体样式信息了。

其实计算的方式也并不复杂，主要就是两个规则`层叠`和`继承`；

每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫`UserAgent样式`。这就是继承规则，非常容易理解。

然后是层叠规则，CSS 最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果，甚至有很多诡异的层叠现象，看过《CSS 世界》的同学应该对此深有体会，具体的层叠规则属于深入 css 的内容，这里就不过多的介绍了。

不过值得注意的是，在计算完样式之后，所有的样式值会被挂载到`window.getComputedStyle`当中，也就是可以通过 JS 来获取计算后的样式，非常方便。

#### 生成布局树

现在已经生成了`DOM树`和`DOM样式`，接下来的就是通过浏览器的布局系统`确定元素的位置`，也就是要生成一棵`布局树`（Layout Tree）

布局树生成过程大致如下：

1. 遍历生成的 DOM 树节点，并把它们添加到`布局树`中。
2. 计算布局树节点的坐标位置

值得注意的是，这棵布局树包含可见元素，对于`head`标签和设置了`display: none`的元素，将不会被放入其中。

有人说会首先生成渲染树，也就是`Render Tree`，其实这还是 16 年前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成`Render Tree`的过程了。而布局树的信息已经非常完善，完全拥有`Render Tree`的功能。

#### 总结

梳理下这一节的主要脉络：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d65fc0701bce4da594dbc764602e5947~tplv-k3u1fbpfcp-watermark.image)

## 渲染过程

之前我们介绍了浏览器`解析`的过程，其中包含`构建DOM`和`构建布局树`。
接下来就是下一个过程——`渲染`

- 建立`图层树`
- 生成`绘制列表`
- 生成`图块`并`栅格化`
- 显示器显示内容

### 建图层树

如果你觉得现在`DOM节点`也有了，样式和位置信息也有了，可以开始绘制页面了，那你就错了。

因为你考虑掉了另外一些复杂的场景，比如说 3D 动画该如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。

为了解决上述的问题，浏览器在构建完`布局树`之后，还会对特定的节点进行分层，构建一棵`图层树`

那这棵图层书是根据什么来构建的呢?

一般情况下节点的图层默认属于父节点的图层（这些图层也称为合成层），那什么时候会提升为一个单独的合成层呢？

有两种情况需要分别讨论，一种是**显式合成**，一种是**隐式合成**。

#### 显式合成

一 拥有层叠上下文的节点

层叠上下文也基本上是由一些特定的 CSS 属性创建的，一般有以下情况：

1. HTML 根元素本身就具有层叠上下文
2. 普通元素设置**position**不为**static**并且设置了**z-index**属性，会产生层叠上下文。
3. 元素的**opacity**的值不是 1
4. 元素的**transform**不是**none**
5. 元素的**filter**不是**none**
6. 元素的**isolation**不是**isolate**
7. **will-change**指定的属性值为上面任意一个。

二 需要**裁剪**的地方

比如一个 div,你只给他设置 100\*100 像素的大小，而你在里面放了很多的文字，那么超出文字的部分就需要被裁剪。当然如果出现了滚动条，那么滚动条就会被单独提升为一个图层。

#### 隐式合成

简单来说就是`层叠等级低的节点`被提升为单独的图层后，那么`所有层叠等级比它高`的节点**都会**称为一个单独的图层

这个**隐式合成**其实有巨大的风险，如果一个大型应用中,当一个`z-index`比较低的元素被提升为单独图层之后，层叠在它上面的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是层爆炸原理。这里有一个具体的例子，[点击打开](https://segmentfault.com/a/1190000014520786)

值得注意的是，当需要`repaint`时，只需要`repaint`本身，而不会影响其它的层。

### 生成绘制列表

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景，再描绘边框...然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。

这里我们以百度首页为例，大家可以在 Chrome 开发工具中在设置栏中展开`more tools`，然后选择`Layers`面板，就能看到下面的绘制列表：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d2f5835b4ca464aac7626ca3f20aca4~tplv-k3u1fbpfcp-watermark.image)

### 生成土块和生成位图

现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫合成线程；

绘制列表准备好之后，渲染进程的主线程会给`合成线程`发送`commit`消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候了。

首先考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将图层**分块**。这些块的大小一般不会特别大，通常是 256*256 或者 512*512 这个规格。这样可以大大加速页面的首屏显示。

因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使绘制一部分土块，也可能会耗费大量时间。针对这个问题 Chrome 采用了一个策略：在首次合成图块时只采用一个**低分辨率**的图片，这样首屏显示的时候只是显示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。

顺便提醒一点，渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**。

然后合成线程会选择视口附近的**图块**，把它交给**栅格化线程池**生成位图。

生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给`合成线程`

### 显示器显示内容

栅格化操作完成后，**合成线程**会生成一个绘制命令，即"DrawQuad",并发送给浏览器进程。

浏览器进程中的`viz组件`接收到这个命令，根据这个命令，把也买你内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成响应的图像，并将图像保存到**后缓冲区**，然后系统自动将`前缓冲区`和`后缓冲区`对换位置，如此循环更新。

看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。

### 总结

到这里总算是把整个流程走通了，现在重新来梳理一下页面渲染的流程。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f0101df2164105b4c2d94d8dc32b1d~tplv-k3u1fbpfcp-watermark.image)

## 重绘和回流

我们先来回顾一下`渲染流水线`的流程

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5e6f1d130484c6799a89723d40547f5~tplv-k3u1fbpfcp-watermark.image)

接下来我们将依此来介绍重绘和回流，以及更新视图的另外一种方式——合成。

### 回流

首先介绍`回流`。`回流`也叫`重排`。

#### 触发条件

简单来说，就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生`回流`的过程。

具体一点，有以下操作会触发回流：

1. 一个 DOM 元素的几何属性变化，常见的集合属性有`width` `height` `padding` `margin` `left` `top` `border`等等，这个很好理解
2. 使 DOM 节点发生`增减`或者`移动`。
3. 读写`offset`族，`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。
4. 调用`window.getComputedStyle`方法。

#### 回流过程

依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程（包括主线程之外的任务）全部走一遍。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a47b97db191c4782b024716aafaa8420~tplv-k3u1fbpfcp-watermark.image)

相当于将解析和合成 的过程重新走了一遍，开销使非常大的。

### 重绘

#### 触发条件

当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘（repaint）`

#### 重绘过程

由于没有导致 DOM 几何属性的变化，因此元素的位置不需要更新，从而省区布局的过程。流程如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d4b88f664e1470dac758c5ea71e4849~tplv-k3u1fbpfcp-watermark.image)

跳过了`生成布局树`和`建图层树`的阶段，直接生成绘制列表，然后继续进行分块 生成位图等后面一系列操作。

可以看到重绘不一定导致回流，回流一定会导致重绘。

### 合成

还有一种情况，是直接合成。比如利用 CSS3 的`transform` `opacity` `filter`这些属性就可以实现合成的效果，也就是大家常说的**GPU**加速。

#### GPU 加速的原因

在合成的情况下，会直接跳过布局和绘制流程，直接进入`非主线程`处理的部分，即直接交给`合成线程`处理。交给他处理有两大好处：

1. 能充分发挥`GPU`的优势。合成线程生成位图的过程中会调用线程池，并在其中使用`GPU`进行加速生成，而 GPU 是擅长处理位图数据的。

2. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅的显示。

### 实践意义

1. 避免频繁使用 style,而是采用修改`class`的方式

2. 使用`createDocumentFragment`进行批量的 DOM 操作。

3. 对于`resize` `scroll`等进行防抖/节流处理。

4. 添加`will-change:tranform`让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于`tranform`，任何可以实现合成效果的 CS 属性都能用`will-change`来声明。这里有一个实际的例子，一行`will-change:tranform`拯救一个项目。[点击直达。](https://juejin.cn/post/6844903966573068301)

**参考文章**

1. [实践这一次,彻底搞懂浏览器缓存机制](https://juejin.cn/post/6844903764566999054)
2. [(1.6w 字)浏览器灵魂之问，请问你能接得住几个？](https://juejin.cn/post/6844904021308735502#heading-24)
